本稿では、自動テストについての「ちょうど一歩くらい」進んだ内容について、述べていきます。

これを読むことによって、テストを実施するための考え方がわかるようになります。

対象読者:
- **テストの概要はわかった**（[単体テストと結合テストガイドライン](https://zenn.dev/aiya000/articles/978fa504b1da3f)を読んだ）
- 実際にテストを実装してみようと思ったけど、**とっかかりがつかめなかった**
- テストのTipsに興味がある

なお本稿は株式会社HIKKYフロントエンドチーム向けのガイドラインであるものの、内容については筆者に一任されており、**株式会社HIKKY及びその意向等とは無関係です。**

# テストってどういうフローで開発していくの？ どのタイミングでテストコードを書くの？

おおまかには以下の、2通りのテスト開発フローがあります。
この2通りをプロジェクトごとに規定するか、また規定がなければ、そのときの作業者の裁量で採用するとよいでしょう。

- テスト駆動開発（TDD）
    - **テストを書いてから**、実装を書く
- 実装駆動開発
    - **実装を書いてから**、テストを書く

これについて、少し詳しく解説していきます。

- - - - -

**両方を採用する**

ちなみにですが、実際は双方のいいとこ取りをした（上記2つの両方を採用した）
「テストを書いてから、実装を書いて、そのあとにまたテストを書く」
という手法もあります。

- - - - -

それを踏まえて、見ていきましょう。

## テスト駆動開発（TDD）

TDDとは、おおまかに言って「**最初にテスト**を書いて、そのあとに実装を書く」フローのことです。

実際の流れは下記の記事でとてもよく述べられているので、下記の記事の「1. テスト駆動開発(TDD)」を参照してください。
（BDDについては読む必要はありません。ただし興味深いので、読んでも問題ありません。）

- [アジャイル開発における「TDD」と「BDD」 - SHIFT ASIA -ソフトウェア品質保証のプロフェッショナル-](https://shiftasia.com/ja/column/%E3%82%A2%E3%82%B8%E3%83%A3%E3%82%A4%E3%83%AB%E9%96%8B%E7%99%BA%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8Btdd%E3%81%A8bdd/)

TDDの利点は以下です。
- 一度テストを書いてしまえば、テストが通る状態を目指すように、実装を行える
- 実装への先入観なしに、テストを書くことができる

TDDの欠点は以下が挙げられます。
- 実装なしにテストを書くのが重い。実装を元にテストを書いた方が楽
- そもそもテストを書くコストが高い。テストを書く暇がない

## 実装駆動開発

実装駆動開発とは、おおまかに言って「**最初に実装**を書いて、そのあとにテストを書く」フローのことです。

あまり一般的に「実装駆動開発」という用語が用いられないので、ここではこの用語を下記のフローのこと、と定義します。

1. 実装を書く
1. テストを書く
1. テストを実行する
    - テストが通らなかったら、実装を修正する
1. 必要があれば、実装のリファクタリングをする
1. テストを実行する
    - テストが通ることを確認する

TDDと比べて、実装とテストが真逆の順番になっていることがわかります。
実装駆動開発は、テストよりも実装を先に行います。

実装駆動開発の利点は以下です。
- 最悪の場合、テストを書かないでも、納品することができる
- 実装を見ながら、それが満たすであろうテストを書ける

実装駆動開発の欠点は以下が挙げられます。
- 実装をするときに、それが満たすべき性質（を表すテスト）が手元にない
- 実装への先入観があるので、実装と独立したテストが書きにくい。実装が当然満たすであろうテストしか書けなくなる [^by-PBT]

# テストってどういう観点でどういう内容を書くべきなの？
## 単体テスト

単体テストでは、下記の点について着目すべきです。

- 「下記の項目」に対して、所望の性質を満たすこと
    - **ある特定の値**に対して
    - **ある境界**に対して
    - **全ての値**に対して

また「**不正な値**」に対して、所望の性質を**満たさない**ことを確認するのも、重要です。

具体的なコードを見ていきましょう。

### ある特定の値に対して、性質を満たす

これはテストにおいて、最も単純な考え方です。

例えば、下記の関数`div`で、第二引数`0`の場合に例外をthrowすること…を確認するとき、この観点が使えます。

```typescript
function div(x: number, y: number): number {
  if (y === 0) {
    throw new Error('Div By Zero')
  }
  return x / y
}
```

```typescript
test('throws if div by zero', () => {
  const randomValue = 42 // 適当な値
  expect(() => div(randomValue, 0)).toThrow()
})
```

どの観点でテストを書くか迷った場合は、これに立ち戻るのがよいでしょう。

ただし、この観点でテストを書くと、テストケースは不足しがちです。
もし不足しがちだと感じた場合は、他の観点を試みてください。

テストケースが単純でよい場合のみ、これを採用してください。

### ある境界に対して、性質を満たす

これはテストにおいて、実用的な考え方です。

テスト対象が「**境界**」を持つ場合に、この観点が使えます。

では、境界とはなんでしょうか。
境界とは、テスト対象がある値（**境界値**）の前後によって挙動が変わる場合の、その境界値の前後のことを指します。

例えば関数`f`が

- 41以下の場合
- 42以上の場合

で処理を分岐する場合、`41, 42`が境界です。
そして`41`と`42`が境界値です。

その場合に

- 41以下の場合
- 42以上の場合

に対してテストケースを作成するのが、本観点になります。

- - - - -

余談ですが、この文脈では
「x**より大きい**」
「x**以上**」、そして
「y**より小さい**」
「y**以下**」
の違いが重要なので、混同しないで考えるようにしましょう。

- - - - -

具体例を見てみましょう。

```typescript
function range(start: number, end: number): Array<number> {
  if (start < 0) {
    const result: Array<number> = []
    for (let i = start; i >= end; i--) {
      result.push(i)
    }
    return result
  }

  // start >= 0 の場合
  const result: Array<number> = []
  for (let i = start; i <= end; i++) {
    result.push(i)
  }
  return result
}
```

`if (start < 0)`でわかる通り、この関数`range`の境界は（`start`に対して）`-1, 0`です。

まとめると、境界は以下にあることになります。

- -1以下の場合
- 0以上の場合

境界値は`-1`, `0`です。

確認してみましょう。

```typescript
console.log(range(0, 10))
// [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]

console.log(range(-1, -10))
// [ -1, -2, -3, -4,  -5, -6, -7, -8, -9, -10 ]
```

startが**0以上**であるか、**-1以下**であるかで動作が変わっていることが、確かにわかりますね。

この場合のテストケースも単純で、次のように記述します。

```typescript
test('makes lists by positive steps', () => {
  expect(range(0, 10)).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
})

test('makes lists by positive steps', () => {
  expect(range(-1, -10)).toEqual([-1, -2, -3, -4, -5, -6, -7, -8, -9, -10])
})
```

以上が「ある境界に対して、性質を満たす」の観点でした。

この観点は、非常に応用が効きます。
テストケースを考えた際に

- 境界が分かれている
- 後述の「全ての値に対して、性質を満たす」を使うほどでもない

といった場合は、境界値の観点を使うとよいでしょう。

ちなみにこの観点を使ったテストを、特別に
「**境界値分析**」
または
「**境界値テスト**」
と言います。

#### 応用: 同値分割

境界値でテストケースを作成する際に、境界値のみのテストだとケースが不足していると感じることがあります。
例えば上述の`'makes lists by positive steps'`や`'makes lists by positive steps'`のテストでは、ケースが1つずつしかありません。

その場合は「**同値分割**」を使うとよいです。

同値分割では、境界値を区切りにした区間の値群（同値の値）をテストケースに用います。

`'makes lists by positive steps'`と`'makes lists by positive steps'`のテストで同値分割を使ってみると、次のようになります。

```typescript
test('makes lists by positive steps', () => {
  // start >= 0 のケース
  expect(range(0, 10)).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
  expect(range(1, 10)).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
  expect(range(5, 10)).toEqual([5, 6, 7, 8, 9, 10])
})

test('makes lists by positive steps', () => {
  // start < 0 のケース
  expect(range(-1, -10)).toEqual([-1, -2, -3, -4, -5, -6, -7, -8, -9, -10])
  expect(range(-2, -10)).toEqual([-2, -3, -4, -5, -6, -7, -8, -9, -10])
  expect(range(-5, -10)).toEqual([-5, -6, -7, -8, -9, -10])
})
```

「`start >= 0`のケース」や「`start < 0` のケース」へのテストなのが、わかりやすくなりましたね！
これが同値分割です。

ただし**テストケースは多ければいいというものではない**ので、可能であれば増やしすぎず、クリティカルなテストケースだけを記述するようにしましょう。

- 参考
    - [単体テストのテスト項目の観点  |  ソフトウェア雑記](https://softwarenote.info/p738/)

<!-- この定義の方が実用的、というか本来こうあるべきだったけど、話が難しくなるのでボツ。

```typescript
function range(start: number, end: number): Array<number> {
  if (end === start) {
    return [end]
  }

  if (end < start) {
    const result: Array<number> = []
    for (let i = start; i >= end; i--) {
      result.push(i)
    }
    return result
  }

  // end > start の場合
  const result: Array<number> = []
  for (let i = start; i <= end; i++) {
    result.push(i)
  }
  return result
}
```

```typescript
const end = 5

test('makes singleton lists', () => {
  expect(range(5, end)).toEqual([5])
})

test('makes lists by positive steps', () => {
  expect(range(0, end)).toEqual([0, 1, 2, 3, 4, 5])
})

test('makes lists by positive steps', () => {
  expect(range(10, end)).toEqual([10, 9, 8, 7, 6, 5])
})
```

-->

### 全ての値に対して、性質を満たす

### 不正な値に対して、性質を満たさないこと

## スナップショットテスト
## VRT
## 結合テスト
### UIコンポーネント
### E2Eテスト
# 具体的な書き方のOKパターンとNGパターン
例えばコードの書き方はTSガイドラインに準拠等。

- - - - -
- - - - -

[^by-PBT]: Property Based Testingでテストケースをランダムに作成することにより、ある程度は未知に対するテストを書くことができます。Property Based Testingについては、[単体テストと結合テストガイドライン](https://zenn.dev/aiya000/articles/978fa504b1da3f)の「さいごに」を参照してください。」
