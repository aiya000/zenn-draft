本稿では、自動テストについての「ちょうど一歩くらい」進んだ内容について、述べていきます。

これを読むことによって、テストを実施するための考え方がわかるようになります。

対象読者:
- **テストの概要はわかった**（[単体テストと結合テストガイドライン](https://zenn.dev/aiya000/articles/978fa504b1da3f)を読んだ）
- 実際にテストを実装してみようと思ったけど、**とっかかりがつかめなかった**
- テストのTipsに興味がある

なお本稿は株式会社HIKKYフロントエンドチーム向けのガイドラインであるものの、内容については筆者に一任されており、**株式会社HIKKY及びその意向等とは無関係です。**

# テストってどういうフローで開発していくの？ どのタイミングでテストコードを書くの？

おおまかには以下の、2通りのテスト開発フローがあります。
この2通りをプロジェクトごとに規定するか、また規定がなければ、そのときの作業者の裁量で採用するとよいでしょう。

- テスト駆動開発（TDD）
    - **テストを書いてから**、実装を書く
- 実装駆動開発
    - **実装を書いてから**、テストを書く

これについて、少し詳しく解説していきます。

- - - - -

**両方を採用する**

ちなみにですが、実際は双方のいいとこ取りをした（上記2つの両方を採用した）
「テストを書いてから、実装を書いて、そのあとにまたテストを書く」
という手法もあります。

- - - - -

それを踏まえて、見ていきましょう。

## テスト駆動開発（TDD）

TDDとは、おおまかに言って「**最初にテスト**を書いて、そのあとに実装を書く」フローのことです。

実際の流れは下記の記事でとてもよく述べられているので、下記の記事の「1. テスト駆動開発(TDD)」を参照してください。
（BDDについては読む必要はありません。ただし興味深いので、読んでも問題ありません。）

- [アジャイル開発における「TDD」と「BDD」 - SHIFT ASIA -ソフトウェア品質保証のプロフェッショナル-](https://shiftasia.com/ja/column/%E3%82%A2%E3%82%B8%E3%83%A3%E3%82%A4%E3%83%AB%E9%96%8B%E7%99%BA%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8Btdd%E3%81%A8bdd/)

TDDの利点は以下です。
- 一度テストを書いてしまえば、テストが通る状態を目指すように、実装を行える
- 実装への先入観なしに、テストを書くことができる

TDDの欠点は以下が挙げられます。
- 実装なしにテストを書くのが重い。実装を元にテストを書いた方が楽
- そもそもテストを書くコストが高い。テストを書く暇がない

## 実装駆動開発

実装駆動開発とは、おおまかに言って「**最初に実装**を書いて、そのあとにテストを書く」フローのことです。

あまり一般的に「実装駆動開発」という用語が用いられないので、ここではこの用語を下記のフローのこと、と定義します。

1. 実装を書く
1. テストを書く
1. テストを実行する
    - テストが通らなかったら、実装を修正する
1. 必要があれば、実装のリファクタリングをする
1. テストを実行する
    - テストが通ることを確認する

TDDと比べて、実装とテストが真逆の順番になっていることがわかります。
実装駆動開発は、テストよりも実装を先に行います。

実装駆動開発の利点は以下です。
- 最悪の場合、テストを書かないでも、納品することができる
- 実装を見ながら、それが満たすであろうテストを書ける

実装駆動開発の欠点は以下が挙げられます。
- 実装をするときに、それが満たすべき性質（を表すテスト）が手元にない
- 実装への先入観があるので、実装と独立したテストが書きにくい。実装が当然満たすであろうテストしか書けなくなる [^by-PBT]

# テストってどういう観点でどういう内容を書くべきなの？
## 単体テスト

単体テストでは、下記の点について着目すべきです。

- 「下記の項目」に対して、所望の性質を満たすこと
    - **ある特定の値**に対して
    - **ある境界**に対して
    - **全ての分岐**に対して
    - **全ての値**に対して

具体的なコードを見ていきましょう。

### ある特定の値に対して、性質を満たす

これはテストにおいて、最も単純な考え方です。

例えば、下記の関数`div`で、第二引数`0`の場合に例外をthrowすること…を確認するとき、この観点が使えます。

```typescript
function div(x: number, y: number): number {
  if (y === 0) {
    throw new Error('Div By Zero')
  }
  return x / y
}
```

```typescript
test('throws if div by zero', () => {
  const randomValue = 42 // 適当な値
  expect(() => div(randomValue, 0)).toThrow()
})
```

どの観点でテストを書くか迷った場合は、これに立ち戻るのがよいでしょう。

ただし、この観点でテストを書くと、テストケースは不足しがちです。
もし不足しがちだと感じた場合は、他の観点を試みてください。

テストケースが単純でよい場合のみ、これを採用してください。

### ある境界に対して、性質を満たす

境界とは、テスト対象がある値（**境界値**）の前後によって挙動が変わる場合の、その境界値の前後のことを指します。

例えば関数`f`が

- 41以下の場合
- 42以上の場合

で処理を分岐する場合、`41, 42`が境界です。
そして`41`と`42`が境界値です。

関数`g`が

- -1以下の場合
- 0の場合
- 1以上の場合

で処理を分岐する場合は、`-1, 0, 1`が境界です。
そして`-1`, `0`, `1`が境界値です。

具体例を見てみましょう。

```typescript
function range(start: number, end: number): Array<number> {
  if (start < 0) {
    const result: Array<number> = []
    for (let i = start; i >= end; i--) {
      result.push(i)
    }
    return result
  }

  const result: Array<number> = []
  for (let i = start; i <= end; i++) {
    result.push(i)
  }
  return result
}
```

TODO

```typescript
console.log(range(0, 10))
console.log(range(-1, -10))
console.log(range(10, -10))

/*

[
   0, 1, 2, 3, 4,
   5, 6, 7, 8, 9,
  10
]
[
  -1, -2, -3, -4,  -5,
  -6, -7, -8, -9, -10
]
[
  10,  9,  8,  7,  6,  5,   4,
   3,  2,  1,  0, -1, -2,  -3,
  -4, -5, -6, -7, -8, -9, -10
]

*/
```

余談ですが、この文脈では
「x**より大きい**」
「x**以上**」
「y**より小さい**」
「y**以下**」
の違いが重要なので、混同しないで考えるようにしましょう。

### 全ての分岐に対して、性質を満たす
### 全ての値に対して、性質を満たす

## スナップショットテスト
## VRT
## 結合テスト
### UIコンポーネント
### E2Eテスト
# 具体的な書き方のOKパターンとNGパターン
例えばコードの書き方はTSガイドラインに準拠等。

- - - - -
- - - - -

[^by-PBT]: Property Based Testingでテストケースをランダムに作成することにより、ある程度は未知に対するテストを書くことができます。Property Based Testingについては、[単体テストと結合テストガイドライン](https://zenn.dev/aiya000/articles/978fa504b1da3f)の「さいごに」を参照してください。」
